# ТЕХНИЧЕСКОЕ ЗАДАНИЕ
## Высокопроизводительная Многостадийная Система Маршрутизации Сообщений без Блокировок

**Автор**: Yan Bubenok
**Email**: yan@bubenok.com
**Telegram**: @iBubenok

**Версия**: 1.0
**Дата**: 2025-11-14
**Статус**: Утверждено

---

## 1. ОБЩИЕ СВЕДЕНИЯ

### 1.1 Наименование проекта
Высокопроизводительная многостадийная система маршрутизации сообщений без блокировок (Multi-Stage Lock-Free Message Router)

### 1.2 Основание для разработки
Проект создан в рамках учебного задания для демонстрации навыков проектирования и реализации высокопроизводительных lock-free систем, характерных для трейдинговых платформ и систем обработки данных в реальном времени.

### 1.3 Цель разработки
Разработать высокопроизводительную систему маршрутизации сообщений, способную обрабатывать миллионы сообщений в секунду при минимальных задержках, используя только атомарные операции без применения блокировок (mutexes, semaphores, condition variables).

### 1.4 Область применения
- Биржевые торговые системы (обработка рыночных данных)
- Системы высокочастотной торговли (HFT)
- Системы обработки потоков данных в реальном времени
- Образовательные цели для изучения lock-free программирования

---

## 2. ТРЕБОВАНИЯ К СИСТЕМЕ

### 2.1 Функциональные требования

#### 2.1.1 Архитектура системы
Система должна состоять из следующих компонентов, организованных в конвейер:

```
Производители (Producers)
    ↓ [SPSC очереди]
Маршрутизатор Стадии 1 (Stage1 Router)
    ↓ [SPSC очереди]
Процессоры (Processors)
    ↓ [SPSC очереди]
Маршрутизатор Стадии 2 (Stage2 Router)
    ↓ [SPSC очереди]
Стратегии (Strategies)
```

#### 2.1.2 Компоненты системы

**Производители (Producers)**
- Количество: 4-8 потоков (конфигурируемо)
- Функция: Генерация сообщений с заданной скоростью
- Параметры:
  - Целевая скорость генерации (сообщений/сек)
  - Распределение типов сообщений (вероятностное)
  - Уникальный ID производителя
  - Монотонно возрастающий номер последовательности

**Маршрутизатор Стадии 1 (Stage1 Router)**
- Количество: 1 поток
- Функция: Маршрутизация сообщений от производителей к процессорам на основе типа сообщения
- Особенности:
  - Поддержка round-robin балансировки при наличии нескольких процессоров для одного типа
  - Детерминированная маршрутизация для типов, требующих сохранения порядка

**Процессоры (Processors)**
- Количество: 4-8 потоков (конфигурируемо)
- Функция: Имитация обработки сообщений с конфигурируемой задержкой
- Параметры:
  - Время обработки для каждого типа сообщения (наносекунды)
  - Busy-waiting для имитации работы
  - Добавление метаданных о процессоре в сообщение

**Маршрутизатор Стадии 2 (Stage2 Router)**
- Количество: 1 поток
- Функция: Маршрутизация обработанных сообщений к стратегиям на основе типа
- Особенности:
  - Детерминированная маршрутизация (тип сообщения → конкретная стратегия)
  - Критичен для сохранения порядка сообщений

**Стратегии (Strategies)**
- Количество: 2-4 потока (конфигурируемо)
- Функция: Финальное потребление сообщений с валидацией порядка
- Задачи:
  - Проверка порядка сообщений от каждого производителя
  - Сбор статистики задержек
  - Обнаружение нарушений порядка
  - Имитация финальной обработки

#### 2.1.3 Структура сообщения

Каждое сообщение должно содержать:

**Основные поля (устанавливаются производителем):**
- `msg_type` (uint8_t): Тип сообщения (0-7)
- `producer_id` (uint8_t): Идентификатор производителя
- `sequence_number` (uint64_t): Порядковый номер от производителя
- `timestamp_ns` (uint64_t): Временная метка создания (наносекунды)

**Поля обработки (устанавливаются процессором):**
- `processor_id` (uint8_t): Идентификатор процессора
- `processing_ts_ns` (uint64_t): Временная метка обработки

**Поля трассировки (для измерения задержек):**
- `stage1_entry_ns` (uint64_t): Время входа в Stage1 Router
- `stage1_exit_ns` (uint64_t): Время выхода из Stage1 Router
- `processing_entry_ns` (uint64_t): Время входа в Processor
- `processing_exit_ns` (uint64_t): Время выхода из Processor
- `stage2_entry_ns` (uint64_t): Время входа в Stage2 Router
- `stage2_exit_ns` (uint64_t): Время выхода из Stage2 Router

**Требования к структуре:**
- Должна быть trivially copyable (POD-тип)
- Размер ~96 байт (умещается в 2 cache line по 64 байта)

#### 2.1.4 Правила маршрутизации

**Stage1 Rules:**
- Формат: `{msg_type: N, processors: [id1, id2, ...]}`
- Если указано несколько процессоров, используется round-robin
- Для типов, требующих сохранения порядка, должен быть указан только один процессор

**Stage2 Rules:**
- Формат: `{msg_type: N, strategy: id, ordering_required: true/false}`
- Каждый тип сообщения маршрутизируется ровно к одной стратегии
- Флаг `ordering_required` указывает, требуется ли строгий порядок

#### 2.1.5 Критическое требование: Сохранение порядка сообщений

**Инвариант:**
Сообщения от одного производителя с одним типом должны прибывать в стратегии в порядке возрастания номеров последовательности.

**Пример:**
- Producer-0 отправляет: `[type-0, seq-1]`, `[type-0, seq-2]`, `[type-0, seq-3]`
- Strategy должна получить их как: `seq-1`, `seq-2`, `seq-3` (никогда не out-of-order)
- Сообщения от разных производителей могут чередоваться произвольно

**Механизм обеспечения:**
1. Производители присваивают монотонные номера последовательности
2. SPSC очереди обеспечивают FIFO порядок
3. Детерминированная маршрутизация: для типов с `ordering_required=true` должна быть фиксированная маршрутизация (1 производитель → 1 процессор → 1 стратегия для данного типа)
4. Стратегии валидируют порядок путем отслеживания последнего `sequence_number` для каждой пары `(producer_id, msg_type)`

### 2.2 Нефункциональные требования

#### 2.2.1 Производительность

**Целевые метрики:**

| Метрика | Целевое значение |
|---------|------------------|
| Общая пропускная способность | ≥ 10 миллионов сообщений/сек |
| End-to-end задержка (p99) | < 5 микросекунд |
| Потеря сообщений | 0 (ноль) |
| Нарушения порядка | 0 (ноль) |

**Дополнительные требования:**
- Задержка в Stage1 Router (p99) < 1 микросекунда
- Задержка в Stage2 Router (p99) < 1 микросекунда
- CPU usage: 100% на задействованных ядрах (busy-waiting для минимальной задержки)
- Масштабируемость: линейный рост производительности до 8 производителей

#### 2.2.2 Требования к lock-free дизайну

**Обязательные требования:**
1. Запрещено использовать:
   - `std::mutex`
   - `std::shared_mutex`
   - `std::recursive_mutex`
   - `std::condition_variable`
   - `std::semaphore`
   - Любые блокировки POSIX (pthread_mutex и т.д.)

2. Разрешено использовать только:
   - `std::atomic` с явным указанием memory ordering
   - Атомарные операции (load, store, fetch_add, compare_exchange и т.д.)
   - Lock-free структуры данных

3. Модель памяти:
   - `relaxed` для операций, видимых только одному потоку
   - `acquire/release` для синхронизации producer-consumer
   - Запрещено использовать `seq_cst` (слишком дорого)

4. Предотвращение false sharing:
   - Cache-line alignment (`alignas(64)`) для атомарных переменных
   - Разделение head/tail индексов очередей по разным cache lines

5. Busy-waiting:
   - Использовать вместо sleep для минимальной задержки
   - Применять CPU hint `__builtin_ia32_pause()` в циклах ожидания

#### 2.2.3 Обработка backpressure

**Стратегия:**
При заполнении очереди производитель/роутер должен выполнять busy-wait:
```cpp
while (!queue->try_push(msg)) {
    __builtin_ia32_pause();  // CPU hint для spin-wait
}
```

**Последствия:**
- Естественное регулирование потока (flow control)
- 100% использование CPU
- Отсутствие потери сообщений

#### 2.2.4 Требования к конфигурации

Система должна конфигурироваться через JSON файлы со следующими параметрами:

```json
{
    "scenario": "название_сценария",
    "duration_secs": 10,
    "producers": {
        "count": 4,
        "messages_per_sec": 1000000,
        "distribution": {
            "msg_type_0": 0.25,
            "msg_type_1": 0.25,
            ...
        }
    },
    "processors": {
        "count": 4,
        "processing_times_ns": {
            "msg_type_0": 100,
            ...
        }
    },
    "strategies": {
        "count": 3,
        "processing_times_ns": {
            "strategy_0": 100,
            ...
        }
    },
    "stage1_rules": [...],
    "stage2_rules": [...]
}
```

#### 2.2.5 Мониторинг и отчетность

**Real-time мониторинг (каждую секунду):**
```
[1.00s] Produced: 4.00M | Processed: 3.98M | Delivered: 3.95M | Lost: 0
        Stage1 Queues: [256, 312, 298, 189] | Stage2 Queues: [512, 234, 445]
        Latencies(μs) - Stage1: 0.34 | Processing: 0.18 | Stage2: 0.41 | Total: 1.23
```

**Финальный отчет:**
```
=== PERFORMANCE SUMMARY ===
Scenario: baseline
Duration: 10.00 seconds

Message Statistics:
  Total Produced:     40,000,000
  Total Processed:    40,000,000
  Total Delivered:    40,000,000
  Messages Lost:      0

Latency Percentiles (microseconds):
  Stage      p50    p90    p99    p99.9   max
  Stage1    0.12   0.23   0.45    1.2   15.3
  Process   0.15   0.18   0.21    0.5    2.1
  Stage2    0.18   0.31   0.52    1.1   12.1
  Total     0.51   0.89   1.45    3.2   28.4

Ordering Validation:
  Producer 0: 10,000,000 messages - IN ORDER ✓
  Producer 1: 10,000,000 messages - IN ORDER ✓
  Producer 2: 10,000,000 messages - IN ORDER ✓
  Producer 3: 10,000,000 messages - IN ORDER ✓

Test Result: PASSED
```

### 2.3 Тестовые сценарии

Система должна корректно обрабатывать следующие сценарии:

#### Сценарий 1: Baseline (10 секунд)
- 4 производителя × 1M сообщений/сек = 4M всего/сек
- Равномерное распределение типов сообщений (25% каждого типа 0-3)
- Проверка: Все сообщения доставлены в порядке, нет потерь

#### Сценарий 2: Hot Message Type (15 секунд)
- 70% сообщений типа-0 (hotspot)
- 10% для каждого из типов 1-3
- Проверка: Система справляется с несбалансированной нагрузкой

#### Сценарий 3: Burst Traffic (20 секунд)
- Чередующийся паттерн каждые 2 секунды:
  - 200мс burst: 5× нормальной скорости (20M сообщений/сек)
  - 1800мс quiet: 0.5× нормальной скорости (2M сообщений/сек)
- Проверка: Очереди обрабатывают всплески без потерь

#### Сценарий 4: Imbalanced Processing (15 секунд)
- Разное время обработки по типам:
  - Type-0: 50 нс (быстро)
  - Type-1: 500 нс (средне)
  - Type-2: 2000 нс (медленно - bottleneck)
  - Type-3: 100 нс (быстро)
- Проверка: Медленный процессор не блокирует остальных

#### Сценарий 5: Ordering Stress Test (10 секунд)
- Все производители отправляют только сообщения типа-0
- Все идут через один процессор к одной стратегии
- 8M сообщений/сек всего
- Проверка: Идеальный порядок несмотря на экстремальную конкуренцию

#### Сценарий 6: Strategy Bottleneck (20 секунд)
- Strategy-0 обрабатывает медленно (1000нс на сообщение)
- Strategies 1-2 обрабатывают быстро (50нс на сообщение)
- Проверка: Обработка backpressure без потери сообщений

### 2.4 Бенчмарки

Система должна включать следующие бенчмарки (Google Benchmark):

#### Benchmark 1: Queue Performance
- Измерение пропускной способности SPSC очереди в изоляции
- Варианты: разные размеры сообщений, разные размеры очередей

#### Benchmark 2: Routing Latency
- Overhead логики маршрутизации vs прямого доступа к очереди
- Сравнение с идеальным временем передачи

#### Benchmark 3: Memory Allocation
- Паттерны аллокации памяти в steady state
- Использование памяти при разных сценариях нагрузки
- Влияние размера очередей на производительность

#### Benchmark 4: Scaling
- Производительность при разном количестве производителей (1, 2, 4, 8)
- Производительность при разном количестве процессоров (1, 2, 4, 8)
- Выявление узких мест масштабирования

---

## 3. ТРЕБОВАНИЯ К ОКРУЖЕНИЮ И РАЗВЕРТЫВАНИЮ

### 3.1 Технологический стек

**Язык программирования:**
- C++20 (минимум C++17)
- Причина: Необходимы современные atomic и memory model возможности

**Компилятор:**
- Clang 19+ (обязательно)
- Причина: Лучшая поддержка оптимизаций для lock-free кода

**Система сборки:**
- CMake 3.20+

**Библиотеки:**
- nlohmann/json v3.11.3 (для конфигурации, auto-fetch)
- Google Benchmark v1.8.3 (для бенчмарков, auto-fetch)
- pthread (для потоков)

**Операционная система:**
- Linux (Ubuntu 22.04+) - рекомендовано
- Использует `__builtin_ia32_pause` для x86

### 3.2 Docker окружение

#### 3.2.1 Dockerfile требования

**Multi-stage build:**
- Stage 1 (builder): Компиляция с оптимизациями
  - Base: Ubuntu 22.04
  - Установка clang-19, cmake, git, build tools
  - Флаги оптимизации: `-O3 -march=native -DNDEBUG`
  - Параллельная сборка: `make -j$(nproc)`

- Stage 2 (runtime): Минимальный runtime образ
  - Base: Ubuntu 22.04
  - Только runtime зависимости (libc++, libc++abi)
  - Непривилегированный пользователь для безопасности
  - Volume mounts для конфигураций и результатов

#### 3.2.2 Docker Compose требования

**Сервисы:**
1. `router-test`: Запуск тестовых сценариев
2. `queue-benchmark`: Бенчмарк очередей
3. `routing-benchmark`: Бенчмарк маршрутизации
4. `memory-benchmark`: Бенчмарк памяти
5. `scaling-benchmark`: Бенчмарк масштабирования
6. `all-benchmarks`: Последовательный запуск всех бенчмарков

**Настройки ресурсов:**
- CPU limits: 4-8 ядер (по сценарию)
- Memory limits: 2-4 GB
- CPU shares: 1024 (высокий приоритет)
- mem_swappiness: 0 (отключить swap)

**Environment variables:**
- `OMP_NUM_THREADS`: Количество потоков OpenMP
- `OMP_PROC_BIND=true`: Привязка потоков к ядрам

#### 3.2.3 Использование

```bash
# Сборка
docker-compose build

# Запуск конкретного сценария
docker-compose run router-test configs/baseline.json

# Запуск всех бенчмарков
docker-compose run all-benchmarks

# Результаты сохраняются в ./results/
```

### 3.3 Настройки производительности

**CPU Governor:**
- Должен быть установлен в режим "performance"
- Команда: `echo performance > /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor`

**CPU Affinity:**
- Рекомендуется привязка потоков к конкретным ядрам
- Избегать гипертрединга для критичных потоков

**NUMA:**
- Для NUMA систем желательна привязка памяти к локальной NUMA ноде

---

## 4. ТРЕБОВАНИЯ К ДОКУМЕНТАЦИИ

### 4.1 Код документация

**Требования:**
- Комментарии к lock-free операциям с объяснением memory ordering
- Документация критических секций и алгоритмов
- Объяснение архитектурных решений в заголовочных файлах

### 4.2 Техническая документация

**Обязательные документы:**
1. `README.md`: Инструкции по сборке и запуску (Docker)
2. `ARCHITECTURE.md`: Описание архитектуры и lock-free дизайна
3. `CLAUDE.md`: Руководство для работы с кодовой базой проекта
4. `REPORT.md`: Анализ производительности и результаты тестов

**Содержание ARCHITECTURE.md:**
- Диаграммы компонентов и потоков данных
- Объяснение lock-free дизайна SPSC очередей
- Механизм обработки backpressure
- Стратегия управления памятью
- Memory ordering rationale

**Содержание REPORT.md:**
- Результаты всех 6 тестовых сценариев
- Результаты всех бенчмарков
- Выявленные узкие места (bottlenecks)
- Примененные оптимизации
- Trade-offs в дизайне

### 4.3 Результаты тестов

**Структура директории results/:**
```
results/
├── baseline_summary.txt
├── hot_type_summary.txt
├── burst_pattern_summary.txt
├── imbalanced_processing_summary.txt
├── ordering_stress_summary.txt
├── strategy_bottleneck_summary.txt
└── benchmarks/
    ├── queue_benchmark.json
    ├── routing_benchmark.json
    ├── memory_benchmark.json
    └── scaling_benchmark.json
```

---

## 5. КРИТЕРИИ ПРИЕМКИ

### 5.1 Корректность (40%)

**Обязательные критерии:**
- ✅ Нулевая потеря сообщений во всех сценариях
- ✅ Идеальное сохранение порядка (нулевые нарушения)
- ✅ Успешное прохождение всех 6 тестовых сценариев
- ✅ Корректная валидация в финальном отчете

### 5.2 Производительность (30%)

**Целевые метрики:**
- ✅ Пропускная способность ≥ 10M сообщений/сек (baseline)
- ✅ End-to-end latency p99 < 5 микросекунд
- ✅ Эффективное использование CPU (близко к 100% на задействованных ядрах)
- ✅ Линейное масштабирование до 8 производителей

### 5.3 Качество кода (20%)

**Требования:**
- ✅ Чистый, читаемый код с понятной структурой
- ✅ Корректная обработка ошибок
- ✅ Правильное использование memory ordering
- ✅ Отсутствие data races (проверено Thread Sanitizer)
- ✅ Соответствие архитектурным принципам
- ✅ Комментарии для сложных участков кода

### 5.4 Анализ и документация (10%)

**Требования:**
- ✅ Понимание узких мест системы
- ✅ Качественные измерения производительности
- ✅ Инсайты в документации
- ✅ Объяснение trade-offs
- ✅ Полная и актуальная техническая документация

---

## 6. ЭТАПЫ РАЗРАБОТКИ

### Этап 1: Проектирование
- Определение архитектуры компонентов
- Проектирование структур данных (Message, Config)
- Дизайн lock-free SPSC очереди
- Определение интерфейсов компонентов

### Этап 2: Базовая реализация
- Реализация SPSC очереди
- Реализация структуры Message
- Реализация Producer, Processor, Strategy
- Реализация Stage1Router, Stage2Router
- Базовая система статистики

### Этап 3: Интеграция
- Интеграция компонентов в main.cpp
- Реализация системы конфигурации (JSON parsing)
- Система мониторинга в реальном времени
- Финальная система отчетности

### Этап 4: Тестирование
- Создание 6 тестовых конфигураций
- Реализация бенчмарков (Google Benchmark)
- Проверка корректности (ordering, message loss)
- Performance profiling и оптимизация

### Этап 5: Docker окружение
- Dockerfile с multi-stage build
- docker-compose.yml для всех сервисов
- Скрипты автоматизации
- Настройка volumes и ресурсов

### Этап 6: Документация
- README.md с инструкциями
- ARCHITECTURE.md с техническим описанием
- CLAUDE.md для работы с кодовой базой
- REPORT.md с результатами и анализом

---

## 7. ОГРАНИЧЕНИЯ И ПРЕДПОЛОЖЕНИЯ

### 7.1 Ограничения

**Архитектурные:**
- Система предназначена только для x86-64 архитектуры (используется `__builtin_ia32_pause`)
- Максимум 256 производителей (uint8_t для producer_id)
- Максимум 256 процессоров и стратегий
- Максимум 8 типов сообщений (0-7)

**Производительностные:**
- Busy-waiting приводит к 100% CPU usage (trade-off: низкая задержка vs энергопотребление)
- Размер очереди фиксирован на этапе компиляции (нет динамического изменения)
- Sampling задержек (каждое 1000-е сообщение) для снижения overhead

**Функциональные:**
- Нет динамического добавления/удаления компонентов во время работы
- Нет персистентности (все в памяти)
- Нет распределенной обработки (single machine)

### 7.2 Предположения

**Окружение:**
- Достаточно ядер CPU для всех потоков
- Достаточно RAM для всех очередей
- Linux с поддержкой high-resolution clock
- CPU governor настроен на "performance"

**Использование:**
- Запуск в контролируемом окружении (dedicated hardware или контейнер)
- Нет других CPU-интенсивных процессов
- Стабильная частота CPU (no throttling)

---

## 8. ГЛОССАРИЙ

**SPSC Queue** - Single Producer Single Consumer Queue, lock-free очередь для одного производителя и одного потребителя

**Lock-free** - Алгоритмы и структуры данных, гарантирующие progress без использования блокировок

**Busy-waiting** - Активное ожидание в цикле без передачи управления (vs sleep)

**False sharing** - Ситуация, когда два потока работают с разными переменными в одной cache line, вызывая неэффективность

**Memory ordering** - Гарантии порядка выполнения операций с памятью (relaxed, acquire, release, seq_cst)

**Backpressure** - Механизм регулирования потока данных при переполнении обработчиков

**Cache line** - Минимальная единица кеша CPU (обычно 64 байта)

**Trivially copyable** - Тип данных, который можно копировать побайтово (memcpy-safe)

**p50, p90, p99, p99.9** - Процентили распределения (50-й, 90-й, 99-й, 99.9-й)

**HFT** - High-Frequency Trading, высокочастотная торговля

---

## 9. ПРИЛОЖЕНИЯ

### Приложение А: Формат конфигурационного файла

См. раздел 2.2.4 и файлы в директории `configs/`

### Приложение Б: Примеры команд запуска

```bash
# Сборка Docker образа
docker-compose build

# Запуск baseline теста
docker-compose run router-test configs/baseline.json

# Запуск всех тестов последовательно
./scripts/docker_run_all.sh

# Запуск конкретного бенчмарка
docker-compose run queue-benchmark

# Запуск всех бенчмарков
docker-compose run all-benchmarks

# Просмотр результатов
cat results/baseline_summary.txt
cat results/benchmarks/queue_benchmark.json
```

### Приложение В: Настройка CPU для тестирования

```bash
# Установка CPU governor в режим performance (требует root)
echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor

# Отключение турбо-буста для стабильных измерений
echo 0 | sudo tee /sys/devices/system/cpu/intel_pstate/no_turbo

# Проверка текущих настроек
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
```

---

**Конец документа**
