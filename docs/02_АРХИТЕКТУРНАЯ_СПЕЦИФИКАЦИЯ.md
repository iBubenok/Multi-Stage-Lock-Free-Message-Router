# АРХИТЕКТУРНАЯ СПЕЦИФИКАЦИЯ
## Высокопроизводительная Многостадийная Система Маршрутизации Сообщений

**Автор**: Yan Bubenok
**Email**: yan@bubenok.com
**Telegram**: @iBubenok

**Версия**: 1.0
**Дата**: 2025-11-14
**Статус**: Утверждено

---

## 1. ОБЗОР АРХИТЕКТУРЫ

### 1.1 Архитектурный подход

Система реализована с использованием **pipeline (конвейерной) архитектуры** с применением принципов **lock-free программирования** для достижения максимальной производительности и минимальных задержек.

**Ключевые архитектурные принципы:**

1. **Separation of Concerns**: Каждый компонент выполняет одну четко определенную роль
2. **Lock-Free Communication**: Взаимодействие через lock-free SPSC очереди
3. **Busy-Waiting**: Минимизация задержек за счет активного ожидания
4. **Cache-Aware Design**: Выравнивание данных для оптимального использования кеша CPU
5. **Deterministic Routing**: Предсказуемая маршрутизация для гарантии порядка

### 1.2 Высокоуровневая диаграмма

```
┌─────────────┐
│  Producer 0 │────┐
├─────────────┤    │    ┌──────────────┐
│  Producer 1 │────┼───►│  Stage1      │
├─────────────┤    │    │  Router      │
│  Producer 2 │────┼───►│  (1 thread)  │
├─────────────┤    │    └──────┬───────┘
│  Producer 3 │────┘           │
└─────────────┘                │
   [SPSC Queues]               │ [Type-based routing]
                                ▼
                    ┌───────────┴───────────┐
                    │                       │
            ┌───────▼────────┐     ┌───────▼────────┐
            │  Processor 0   │     │  Processor 1   │
            │  (1 thread)    │     │  (1 thread)    │
            └───────┬────────┘     └───────┬────────┘
                    │                      │
            [SPSC]  │              [SPSC]  │
                    │                      │
                    ├──────────┬───────────┤
                    │          │           │
                    ▼          ▼           ▼
            ┌──────────────────────────────┐
            │     Stage2 Router            │
            │     (1 thread)               │
            └──────┬───────────────────────┘
                   │ [Type-based routing]
                   │
       ┌───────────┼───────────┐
       │           │           │
   ┌───▼────┐  ┌──▼─────┐ ┌───▼────┐
   │Strategy│  │Strategy│ │Strategy│
   │   0    │  │   1    │ │   2    │
   └────────┘  └────────┘ └────────┘
   [Validation + Stats]
```

### 1.3 Потоки данных

**Прямой поток (Forward Path):**
1. Producer генерирует Message
2. Message попадает в SPSC очередь к Stage1 Router
3. Stage1 Router читает из очереди, добавляет timestamp, определяет Processor по типу
4. Message передается в SPSC очередь выбранного Processor
5. Processor симулирует обработку (busy-wait), добавляет метаданные
6. Обработанное Message передается в SPSC очередь к Stage2 Router
7. Stage2 Router определяет Strategy по типу сообщения
8. Message передается в SPSC очередь выбранной Strategy
9. Strategy валидирует порядок, собирает статистику

**Обратная связь (Backpressure):**
- Если очередь полная, отправитель выполняет busy-wait с `__builtin_ia32_pause()`
- Естественное замедление производителя при перегрузке
- Гарантия отсутствия потери сообщений

---

## 2. КОМПОНЕНТНАЯ АРХИТЕКТУРА

### 2.1 Producer (Производитель)

**Назначение:** Генерация потока сообщений с заданной скоростью и распределением типов.

**Основные характеристики:**
- **Поток выполнения**: Каждый Producer работает в отдельном потоке
- **Скорость генерации**: Регулируется через интервал времени между сообщениями
- **Распределение типов**: Вероятностное распределение (discrete distribution)
- **Последовательность**: Монотонно возрастающие `sequence_number` для каждого типа

**Структура:**
```cpp
class Producer {
    uint8_t id_;                      // Уникальный ID производителя
    uint64_t messages_per_sec_;       // Целевая скорость
    OutputQueue output_queue_;        // SPSC очередь к Stage1 Router

    // Распределение типов
    std::vector<uint8_t> msg_types_;
    std::discrete_distribution<> type_distribution_;

    uint64_t sequence_number_;        // Счетчик последовательности
};
```

**Алгоритм работы:**
```
1. Рассчитать интервал между сообщениями: interval = 1s / messages_per_sec
2. WHILE running:
     a. Сгенерировать тип сообщения согласно распределению
     b. Создать Message с текущим sequence_number
     c. Увеличить sequence_number
     d. WHILE NOT output_queue.try_push(msg):
          __builtin_ia32_pause()  # Busy-wait если очередь полная
     e. Подождать interval наносекунд для контроля скорости
```

**Управление скоростью:**
- Точное управление через `std::chrono::nanoseconds`
- Компенсация дрифта времени
- Адаптация к реальному времени выполнения

### 2.2 Stage1 Router (Маршрутизатор 1-й стадии)

**Назначение:** Маршрутизация сообщений от производителей к процессорам на основе типа сообщения.

**Основные характеристики:**
- **Поток выполнения**: Единственный поток (централизованная маршрутизация)
- **Входы**: N SPSC очередей от N производителей
- **Выходы**: M SPSC очередей к M процессорам
- **Логика**: Type-based routing с поддержкой round-robin для балансировки

**Структура:**
```cpp
class Stage1Router {
    // Таблица маршрутизации: msg_type -> [processor_ids]
    std::unordered_map<uint8_t, std::vector<uint8_t>> routing_table_;

    // Входные очереди (от производителей)
    std::vector<InputQueue*> input_queues_;

    // Выходные очереди (к процессорам)
    std::vector<OutputQueue*> output_queues_;

    // Счетчики для round-robin балансировки
    std::unordered_map<uint8_t, std::atomic<size_t>> rr_counters_;
};
```

**Алгоритм маршрутизации:**
```
1. WHILE running:
     2. FOR EACH input_queue IN input_queues:
          3. IF input_queue.try_pop(msg):
               a. Записать stage1_entry_ns timestamp
               b. Определить processor_id = select_processor(msg.type)
               c. Записать stage1_exit_ns timestamp
               d. WHILE NOT output_queues[processor_id].try_push(msg):
                    __builtin_ia32_pause()
```

**Функция select_processor:**
```
IF routing_table[msg_type] содержит один процессор:
    RETURN этот процессор (детерминированная маршрутизация)
ELSE IF routing_table[msg_type] содержит несколько процессоров:
    counter = rr_counters[msg_type].fetch_add(1, relaxed)
    index = counter % processors.size()
    RETURN processors[index]  (round-robin балансировка)
```

**Критично для ordering:**
- Для типов с `ordering_required=true` в конфигурации должен быть указан только один процессор
- Round-robin используется только для типов без требования к порядку

### 2.3 Processor (Процессор)

**Назначение:** Имитация обработки сообщений с конфигурируемым временем задержки.

**Основные характеристики:**
- **Поток выполнения**: Каждый Processor работает в отдельном потоке
- **Вход**: SPSC очередь от Stage1 Router
- **Выход**: SPSC очередь к Stage2 Router
- **Обработка**: Busy-wait на указанное время для имитации работы

**Структура:**
```cpp
class Processor {
    uint8_t id_;                              // Уникальный ID процессора
    InputQueue input_queue_;                  // От Stage1 Router
    OutputQueue output_queue_;                // К Stage2 Router

    // Время обработки для каждого типа сообщения (наносекунды)
    std::unordered_map<uint8_t, uint64_t> processing_times_;
};
```

**Алгоритм работы:**
```
1. WHILE running:
     2. IF input_queue.try_pop(msg):
          a. Записать processing_entry_ns timestamp
          b. delay = processing_times[msg.type]
          c. start_time = current_time()
          d. WHILE (current_time() - start_time) < delay:
               __builtin_ia32_pause()  # Busy-wait для имитации работы
          e. Добавить processor_id и processing_ts_ns в msg
          f. Записать processing_exit_ns timestamp
          g. WHILE NOT output_queue.try_push(msg):
               __builtin_ia32_pause()
     3. ELSE:
          __builtin_ia32_pause()  # Входная очередь пустая
```

**Особенности:**
- Различное время обработки для разных типов позволяет симулировать неоднородную нагрузку
- Busy-waiting вместо sleep для минимизации задержек
- Добавление метаданных о процессоре для трассировки

### 2.4 Stage2 Router (Маршрутизатор 2-й стадии)

**Назначение:** Маршрутизация обработанных сообщений к стратегиям на основе типа.

**Основные характеристики:**
- **Поток выполнения**: Единственный поток
- **Входы**: M SPSC очередей от M процессоров
- **Выходы**: K SPSC очередей к K стратегиям
- **Логика**: Детерминированная маршрутизация (один тип → одна стратегия)

**Структура:**
```cpp
class Stage2Router {
    // Таблица маршрутизации: msg_type -> strategy_id
    std::unordered_map<uint8_t, uint8_t> routing_table_;

    std::vector<InputQueue*> input_queues_;   // От процессоров
    std::vector<OutputQueue*> output_queues_; // К стратегиям
};
```

**Алгоритм маршрутизации:**
```
1. WHILE running:
     2. FOR EACH input_queue IN input_queues:
          3. IF input_queue.try_pop(msg):
               a. Записать stage2_entry_ns timestamp
               b. strategy_id = routing_table[msg.type]
               c. Записать stage2_exit_ns timestamp
               d. WHILE NOT output_queues[strategy_id].try_push(msg):
                    __builtin_ia32_pause()
```

**Критично для ordering:**
- Stage2 Router является точкой, где гарантируется детерминированная маршрутизация
- Для каждого типа сообщения строго определена целевая стратегия
- Отсутствие балансировки на этой стадии критично для сохранения порядка

### 2.5 Strategy (Стратегия)

**Назначение:** Финальная обработка сообщений с валидацией порядка и сбором статистики.

**Основные характеристики:**
- **Поток выполнения**: Каждая Strategy работает в отдельном потоке
- **Вход**: SPSC очередь от Stage2 Router
- **Функции**: Валидация порядка, сбор статистики задержек, имитация финальной обработки

**Структура:**
```cpp
class Strategy {
    uint8_t id_;                      // Уникальный ID стратегии
    InputQueue input_queue_;          // От Stage2 Router
    SystemStatistics& stats_;         // Глобальная статистика
    uint64_t processing_time_ns_;     // Время обработки
};
```

**Алгоритм работы:**
```
1. WHILE running:
     2. IF input_queue.try_pop(msg):
          a. Валидировать порядок: stats.track_message_order(msg)
          b. Записать латентности: stats.record_message_latencies(msg)
          c. Увеличить счетчик: stats.messages_delivered++
          d. Имитировать обработку (busy-wait на processing_time_ns)
     3. ELSE:
          __builtin_ia32_pause()
```

**Валидация порядка:**
- Для каждой пары `(producer_id, msg_type)` отслеживается последний `sequence_number`
- При получении нового сообщения проверяется: `new_seq > last_seq`
- Если условие нарушено, регистрируется ordering violation
- Счетчики хранятся в `OrderTracker` для каждого производителя

---

## 3. LOCK-FREE ДИЗАЙН

### 3.1 SPSC Queue (Single Producer Single Consumer Queue)

**Ключевая структура данных** для межпоточной коммуникации.

**Принцип работы:**
- Кольцевой буфер фиксированного размера (степень 2)
- Два атомарных индекса: `head_` (consumer) и `tail_` (producer)
- Cache-line выравнивание для предотвращения false sharing

**Структура:**
```cpp
template<typename T, size_t Capacity>
class SPSCQueue {
    alignas(64) std::atomic<size_t> head_;  // Consumer index
    alignas(64) std::atomic<size_t> tail_;  // Producer index
    alignas(64) T buffer_[Capacity];        // Кольцевой буфер
};
```

**Операция try_push (producer side):**
```cpp
bool try_push(const T& item) {
    size_t current_tail = tail_.load(std::memory_order_relaxed);
    size_t next_tail = (current_tail + 1) & (Capacity - 1);  // Быстрый modulo

    // Проверка переполнения
    if (next_tail == head_.load(std::memory_order_acquire)) {
        return false;  // Очередь полная
    }

    buffer_[current_tail] = item;  // Запись элемента
    tail_.store(next_tail, std::memory_order_release);  // Публикация
    return true;
}
```

**Операция try_pop (consumer side):**
```cpp
bool try_pop(T& item) {
    size_t current_head = head_.load(std::memory_order_relaxed);

    // Проверка пустоты
    if (current_head == tail_.load(std::memory_order_acquire)) {
        return false;  // Очередь пустая
    }

    item = buffer_[current_head];  // Чтение элемента
    head_.store((current_head + 1) & (Capacity - 1), std::memory_order_release);
    return true;
}
```

**Memory Ordering Rationale:**

| Операция | Memory Order | Обоснование |
|----------|--------------|-------------|
| `tail_.load()` в push | `relaxed` | Producer единственный писатель в tail |
| `head_.load()` в push | `acquire` | Синхронизация с consumer's release в pop |
| `tail_.store()` в push | `release` | Публикация записанного элемента для consumer |
| `head_.load()` в pop | `relaxed` | Consumer единственный писатель в head |
| `tail_.load()` в pop | `acquire` | Получение элемента, опубликованного producer |
| `head_.store()` в pop | `release` | Освобождение слота для producer |

**Ключевые оптимизации:**
1. **Capacity как степень 2**: Позволяет использовать битовую операцию AND вместо модуло
2. **Cache-line alignment (64 байта)**: Предотвращает false sharing между head и tail
3. **Relaxed для локальных операций**: Минимальная синхронизация
4. **Acquire/Release пары**: Обеспечивают happens-before между producer и consumer

### 3.2 Atomic Operations Strategy

**Принципы использования атомарных операций:**

1. **Счетчики статистики**: `std::atomic<uint64_t>` с `memory_order_relaxed`
   ```cpp
   stats.messages_produced.fetch_add(1, std::memory_order_relaxed);
   ```

2. **Флаг остановки**: `std::atomic<bool>` с `acquire/release`
   ```cpp
   // Writer
   running.store(false, std::memory_order_release);

   // Reader
   while (running.load(std::memory_order_acquire)) { ... }
   ```

3. **Round-robin счетчики**: `std::atomic<size_t>` с `memory_order_relaxed`
   ```cpp
   size_t counter = rr_counter.fetch_add(1, std::memory_order_relaxed);
   ```

### 3.3 False Sharing Prevention

**Проблема False Sharing:**
Когда два потока работают с разными переменными, находящимися в одной cache line, возникает неэффективность из-за постоянной инвалидации кеша.

**Решения:**

1. **Выравнивание атомарных переменных:**
   ```cpp
   alignas(64) std::atomic<size_t> head_;
   alignas(64) std::atomic<size_t> tail_;
   ```

2. **Padding между переменными:**
   ```cpp
   struct alignas(64) CacheAlignedCounter {
       std::atomic<uint64_t> value;
       char padding[64 - sizeof(std::atomic<uint64_t>)];
   };
   ```

3. **Разделение read-only и mutable данных:**
   - Константные данные в отдельных структурах
   - Часто изменяемые переменные изолированы

### 3.4 Busy-Waiting Strategy

**Обоснование:**
Trade-off между задержкой и использованием CPU:
- **Sleep/yield**: Низкое CPU usage, но высокая задержка (context switch)
- **Busy-wait**: 100% CPU usage, но минимальная задержка (<< 1 μs)

**Реализация:**
```cpp
while (!condition) {
    __builtin_ia32_pause();  // CPU hint для spin-wait
}
```

**`__builtin_ia32_pause()` эффекты:**
1. Сигнализирует CPU о spin-wait (энергосбережение)
2. Предотвращает спекулятивное выполнение
3. Улучшает производительность hyper-threading
4. Специфично для x86 архитектуры

---

## 4. ОБЕСПЕЧЕНИЕ ГАРАНТИЙ ПОРЯДКА

### 4.1 Механизм сохранения порядка

**Инвариант:** Сообщения от одного производителя с одним типом должны прибывать в порядке возрастания sequence_number.

**Архитектурные механизмы:**

1. **Монотонные sequence numbers:**
   - Каждый Producer присваивает монотонно возрастающие номера
   - Отдельный счетчик для всех сообщений (не разделяется по типам)

2. **FIFO гарантии SPSC очередей:**
   - Очереди обрабатывают элементы строго в порядке добавления
   - Кольцевой буфер с монотонными индексами

3. **Детерминированная маршрутизация:**
   - Для типов с `ordering_required=true`: один тип → один процессор → одна стратегия
   - Отсутствие round-robin для таких типов
   - Stage2 Router всегда детерминирован (один тип → одна стратегия)

4. **Валидация на уровне Strategy:**
   - Отслеживание последнего `sequence_number` для каждой пары `(producer_id, msg_type)`
   - Детекция нарушений порядка
   - Reporting violations в статистике

**Критический путь для ordering:**
```
Producer-X [type-A, seq=N]
    ↓ SPSC Queue (FIFO)
Stage1 Router [детерминированный выбор: type-A → Processor-Y]
    ↓ SPSC Queue (FIFO)
Processor-Y [обработка без переупорядочивания]
    ↓ SPSC Queue (FIFO)
Stage2 Router [детерминированный выбор: type-A → Strategy-Z]
    ↓ SPSC Queue (FIFO)
Strategy-Z [валидация: seq=N > last_seq]
```

### 4.2 Сценарии нарушения порядка и их предотвращение

**Сценарий 1: Round-robin на Stage1 для ordering-critical типа**

❌ **Неправильно:**
```json
{
    "stage1_rules": [
        {"msg_type": 0, "processors": [0, 1]}  // Round-robin
    ],
    "stage2_rules": [
        {"msg_type": 0, "strategy": 0, "ordering_required": true}
    ]
}
```

Проблема: Сообщения от Producer-X с type-0 могут идти через Processor-0 или Processor-1. Из-за разной скорости обработки порядок может нарушиться.

✅ **Правильно:**
```json
{
    "stage1_rules": [
        {"msg_type": 0, "processors": [0]}  // Детерминированно
    ],
    "stage2_rules": [
        {"msg_type": 0, "strategy": 0, "ordering_required": true}
    ]
}
```

**Сценарий 2: Множественные стратегии для одного типа**

❌ **Невозможно** (не поддерживается архитектурой):
Stage2 Router всегда маршрутизирует детерминированно (один тип → одна стратегия).

**Сценарий 3: Параллельная обработка в Processor**

✅ **Безопасно:**
Даже если Processor обрабатывает сообщения с разной скоростью в зависимости от типа, порядок сохраняется, так как:
1. Входная очередь FIFO
2. Обработка последовательная (один поток)
3. Выходная очередь FIFO

### 4.3 Валидация порядка

**Структура OrderTracker:**
```cpp
struct OrderTracker {
    // Последний sequence_number для каждого msg_type
    std::map<uint8_t, uint64_t> last_sequence;

    std::atomic<uint64_t> messages_received{0};
    std::atomic<uint64_t> order_violations{0};
    std::mutex tracker_mutex;  // Защита last_sequence

    void track(const Message& msg) {
        messages_received.fetch_add(1, std::memory_order_relaxed);

        std::lock_guard<std::mutex> lock(tracker_mutex);
        uint8_t key = msg.msg_type;
        auto it = last_sequence.find(key);

        if (it != last_sequence.end()) {
            if (msg.sequence_number <= it->second) {
                order_violations.fetch_add(1, std::memory_order_relaxed);
            }
        }

        last_sequence[key] = msg.sequence_number;
    }
};
```

**Примечание о mutex:**
- OrderTracker использует mutex для защиты `std::map`
- Это **не** нарушает lock-free архитектуру, так как:
  1. Используется только для статистики (не на критическом пути передачи сообщений)
  2. Альтернатива (lock-free map) значительно сложнее без существенного выигрыша
  3. Contention минимален (каждая Strategy имеет свой OrderTracker)

---

## 5. УПРАВЛЕНИЕ ПАМЯТЬЮ И ПРОИЗВОДИТЕЛЬНОСТЬ

### 5.1 Размеры очередей

**Конфигурация:**
```cpp
constexpr size_t PRODUCER_QUEUE_SIZE  = 65536;  // 2^16
constexpr size_t PROCESSOR_QUEUE_SIZE = 65536;  // 2^16
constexpr size_t STRATEGY_QUEUE_SIZE  = 65536;  // 2^16
```

**Обоснование:**
1. **Степень 2**: Быстрые битовые операции для модуло
2. **Размер 65536**: Баланс между:
   - Достаточная буферизация для всплесков (bursts)
   - Разумное использование памяти (~6MB на очередь для Message)
   - Локальность кеша (не слишком большой буфер)

**Расчет использования памяти:**
```
Одна очередь: 65536 * sizeof(Message) = 65536 * 96 ≈ 6.3 MB

Общее для baseline сценария (4 producers, 4 processors, 3 strategies):
- Producer → Stage1:  4 * 6.3 MB = 25.2 MB
- Stage1 → Processor: 4 * 6.3 MB = 25.2 MB
- Processor → Stage2: 4 * 6.3 MB = 25.2 MB
- Stage2 → Strategy:  3 * 6.3 MB = 18.9 MB
Total queues: ~95 MB
```

### 5.2 Cache-line оптимизация

**Message structure layout:**
```
Message (96 bytes = 1.5 cache lines)
├─ [0-7]    msg_type, producer_id, padding
├─ [8-15]   sequence_number
├─ [16-23]  timestamp_ns
├─ [24-31]  processor_id, padding
├─ [32-39]  processing_ts_ns
├─ [40-47]  stage1_entry_ns
├─ [48-55]  stage1_exit_ns
├─ [56-63]  processing_entry_ns  <-- Cache line boundary
├─ [64-71]  processing_exit_ns
├─ [72-79]  stage2_entry_ns
├─ [80-87]  stage2_exit_ns
└─ [88-95]  padding
```

**Оптимальность:**
- ~96 байт = 1.5 cache lines (умещается в 2 cache lines)
- Часто используемые поля (type, producer_id, seq) в первой cache line
- Timestamps для latency tracking в последующих cache lines

### 5.3 Минимизация аллокаций

**Принципы:**
1. **Все очереди pre-allocated**: Выделяются при старте системы
2. **Фиксированные структуры**: Message — POD тип без динамических полей
3. **Zero allocations на hot path**: Нет new/delete в циклах обработки
4. **Stack-based working set**: Локальные переменные в функциях

**Исключения (допустимые аллокации):**
- Векторы для сбора latency statistics (не на критическом пути)
- Контейнеры для routing tables (инициализация)
- Strings для вывода статистики

### 5.4 Латентность и профиль производительности

**Профиль задержек (целевой):**

| Стадия | p50 | p90 | p99 | p99.9 |
|--------|-----|-----|-----|-------|
| Stage1 Router | 0.12μs | 0.23μs | 0.45μs | 1.2μs |
| Processing | 0.15μs | 0.18μs | 0.21μs | 0.5μs |
| Stage2 Router | 0.18μs | 0.31μs | 0.52μs | 1.1μs |
| **Total** | **0.51μs** | **0.89μs** | **1.45μs** | **3.2μs** |

**Компоненты задержки:**
1. **Queue operation overhead**: ~20-50ns (try_push/try_pop)
2. **Router logic**: ~100-200ns (table lookup + timestamp)
3. **Processor simulation**: Configurable (50ns - 2000ns)
4. **Context switches**: 0 (busy-waiting)
5. **Lock contention**: 0 (lock-free design)

---

## 6. МАСШТАБИРОВАНИЕ И ПРОИЗВОДИТЕЛЬНОСТЬ

### 6.1 Горизонтальное масштабирование

**Producers:**
- **Линейное масштабирование**: 1 → 8 производителей
- **Bottleneck**: Stage1 Router (единственный поток)
- **Максимальная пропускная способность Stage1**: ~10-15M msg/s

**Processors:**
- **Масштабирование**: Зависит от типа нагрузки
- **Ограничение**: Скорость обработки самого медленного типа
- **Оптимизация**: Распределение типов между процессорами

**Strategies:**
- **Масштабирование**: Определяется Stage2 Router
- **Bottleneck**: Stage2 Router (единственный поток)

### 6.2 Узкие места (Bottlenecks)

**Выявленные bottlenecks:**

1. **Single-threaded routers:**
   - Stage1 и Stage2 Routers работают в одном потоке
   - При высокой нагрузке могут стать узким местом
   - Mitigation: Минимизация логики в роутерах (только table lookup)

2. **Slow processor/strategy:**
   - Медленная обработка одного типа блокирует очередь к конкретному процессору
   - Backpressure распространяется назад через очереди
   - Mitigation: Балансировка processing times, увеличение размера очередей

3. **Memory bandwidth:**
   - При очень высокой пропускной способности (>20M msg/s)
   - Ограничение скорости чтения/записи в память
   - Mitigation: Минимизация размера Message, cache-friendly layout

### 6.3 CPU Affinity и NUMA

**Рекомендуемая топология привязки:**

```
NUMA Node 0:
├─ Core 0: Producer 0
├─ Core 1: Producer 1
├─ Core 2: Stage1 Router
├─ Core 3: Processor 0
└─ Core 4: Processor 1

NUMA Node 1:
├─ Core 5: Producer 2
├─ Core 6: Producer 3
├─ Core 7: Stage2 Router
├─ Core 8: Processor 2
├─ Core 9: Processor 3
├─ Core 10: Strategy 0
├─ Core 11: Strategy 1
└─ Core 12: Strategy 2
```

**Принципы:**
1. Producers на отдельных ядрах (независимая генерация)
2. Routers на выделенных ядрах (критичны для latency)
3. Processors и Strategies распределены для минимизации contention
4. Избегать hyper-threading для критичных потоков

---

## 7. МОНИТОРИНГ И ДИАГНОСТИКА

### 7.1 Система статистики

**SystemStatistics структура:**
```cpp
class SystemStatistics {
    // Счетчики сообщений
    std::atomic<uint64_t> messages_produced;
    std::atomic<uint64_t> messages_processed;
    std::atomic<uint64_t> messages_delivered;
    std::atomic<uint64_t> messages_lost;

    // Глубины очередей
    std::vector<std::atomic<size_t>> stage1_queue_depths;
    std::vector<std::atomic<size_t>> stage2_queue_depths;

    // Статистика задержек
    LatencyStats stage1_latencies;
    LatencyStats processing_latencies;
    LatencyStats stage2_latencies;
    LatencyStats total_latencies;

    // Валидация порядка
    std::vector<OrderTracker> producer_order_trackers;
};
```

### 7.2 Sampling для снижения overhead

**Стратегия:**
- Записывать latency только для каждого 1000-го сообщения
- Снижает contention на mutex в latency stats
- Достаточная выборка для статистической значимости

```cpp
void record_message_latencies(const Message& msg) {
    if (msg.sequence_number % 1000 != 0) {
        return;  // Skip
    }

    std::lock_guard<std::mutex> lock(latency_mutex);
    stage1_latencies.add(msg.stage1_latency_us());
    // ...
}
```

### 7.3 Real-time мониторинг

**Обновление каждую секунду:**
- Снимок счетчиков сообщений
- Текущие глубины очередей
- Средние latencies за последнюю секунду
- Вывод в консоль для живого мониторинга

### 7.4 Финальный отчет

**Агрегированная статистика:**
- Общее количество сообщений
- Percentiles latencies (p50, p90, p99, p99.9, max)
- Валидация ordering для каждого производителя
- Verdict: PASSED/FAILED

---

## 8. БЕЗОПАСНОСТЬ И НАДЕЖНОСТЬ

### 8.1 Thread Safety

**Гарантии:**
1. **SPSC очереди**: Thread-safe по дизайну (один писатель, один читатель)
2. **Атомарные счетчики**: `std::atomic` с явным memory ordering
3. **Immutable конфигурации**: Инициализируются до старта потоков, затем read-only
4. **Локальные данные**: Каждый поток работает со своими локальными структурами

**Потенциальные race conditions:**
- **Отсутствуют** благодаря строгому разделению ответственности

### 8.2 Обработка ошибок

**Graceful shutdown:**
1. Сигнал SIGINT/SIGTERM устанавливает `g_running = false`
2. Все потоки проверяют флаг в своих циклах
3. Routers и Strategies drainят оставшиеся сообщения из очередей
4. Main поток ждет завершения всех потоков (join)
5. Финальный отчет с актуальной статистикой

**Timeout handling:**
- После установки `running = false`, system ждет до 60 секунд для drain
- Если не все сообщения обработаны, принудительное завершение
- Отчет включает информацию о недоставленных сообщениях

### 8.3 Проверка корректности

**Валидация в SystemStatistics::validate():**
```cpp
bool validate() const {
    // Проверка потерь сообщений
    if (messages_produced != messages_delivered) {
        return false;
    }

    // Проверка ordering violations
    for (const auto& tracker : producer_order_trackers) {
        if (!tracker.is_ordered()) {
            return false;
        }
    }

    return true;
}
```

**Exit code:**
- `0`: Все проверки пройдены
- `1`: Обнаружены ошибки (потери сообщений или нарушения порядка)

---

## 9. ОГРАНИЧЕНИЯ И TRADE-OFFS

### 9.1 Архитектурные ограничения

| Ограничение | Значение | Обоснование |
|-------------|----------|-------------|
| Максимум производителей | 256 | `uint8_t producer_id` |
| Максимум процессоров | 256 | `uint8_t processor_id` |
| Максимум стратегий | 256 | `uint8_t strategy_id` |
| Типов сообщений | 8 (0-7) | `uint8_t msg_type` |
| Размер очереди | 65536 (фиксирован) | Compile-time константа |
| Платформа | x86-64 | `__builtin_ia32_pause` |

### 9.2 Trade-offs

**Busy-waiting vs Sleep:**
- ✅ **Chosen**: Busy-waiting
- **Pros**: Минимальная задержка (<< 1μs)
- **Cons**: 100% CPU usage, высокое энергопотребление
- **Justification**: Приоритет — низкая latency (HFT системы)

**Single-threaded routers vs Multi-threaded:**
- ✅ **Chosen**: Single-threaded
- **Pros**: Простота, отсутствие синхронизации, детерминизм
- **Cons**: Bottleneck при очень высокой нагрузке
- **Justification**: Роутеры выполняют минимум работы (table lookup), редко становятся узким местом

**Fixed-size queues vs Dynamic:**
- ✅ **Chosen**: Fixed-size
- **Pros**: Нет аллокаций, предсказуемое использование памяти
- **Cons**: Нет адаптации к переменной нагрузке
- **Justification**: Размер 65536 достаточен для всех сценариев, упрощает lock-free дизайн

**Mutex в OrderTracker vs Lock-free map:**
- ✅ **Chosen**: Mutex для `std::map`
- **Pros**: Простота, корректность, минимальный overhead (не на критическом пути)
- **Cons**: Теоретически не "чисто" lock-free
- **Justification**: Lock-free map значительно сложнее, выигрыш минимален (статистика)

---

## 10. БУДУЩИЕ УЛУЧШЕНИЯ

### 10.1 Возможные оптимизации

1. **Multi-threaded Stage1 Router:**
   - Partitioning производителей по группам
   - Каждая группа обслуживается отдельным роутером
   - Требует careful sharding для сохранения порядка

2. **Adaptive queue sizing:**
   - Динамическое изменение размера очередей на основе load
   - Сложность: Требует lock-free resizing или сложной синхронизации

3. **NUMA-aware memory allocation:**
   - Привязка очередей к NUMA nodes
   - Снижение latency доступа к памяти

4. **Hardware acceleration:**
   - Использование SIMD для batch processing
   - DPDK для zero-copy networking (если расширить на distributed)

### 10.2 Функциональные расширения

1. **Dynamic component addition:**
   - Добавление/удаление производителей во время работы
   - Сложность: Требует синхронизация для роутеров

2. **Persistence:**
   - Сохранение сообщений на диск для replay
   - Journaling для crash recovery

3. **Distributed mode:**
   - Producers/Processors/Strategies на разных машинах
   - Использование RDMA или fast networking

4. **Advanced routing:**
   - Content-based routing (не только по типу)
   - Priority queues для critical messages

---

**Конец документа**
